"""
serve_select implementation
"""

import inspect
from typing import Any, Callable, Type

from fastapi import Depends, FastAPI, Request
from pydantic import BaseModel, create_model

from dbanu.api.dependencies import create_wrapped_fastapi_dependencies
from dbanu.core.engine import QueryContext, SelectEngine
from dbanu.core.middleware import create_middleware_chain
from dbanu.core.response import create_select_response_model


def serve_select(
    app: FastAPI,
    query_engine: SelectEngine,
    select_query: str,
    select_param: Callable[[BaseModel, int, int], list[Any]] | None = None,
    count_query: str | None = None,
    count_param: Callable[[BaseModel], list[Any]] | None = None,
    path: str = "/get",
    filter_model: Type[BaseModel] | None = None,
    data_model: Type[BaseModel] | None = None,
    dependencies: list[Any] | None = None,
    middlewares: list[Any] | None = None,
    summary: str | None = None,
    description: str | None = None,
):
    """
    Adding fastapi route to app with proper annotation:
    - taking filter_model as parameter
    - return pydantic model with two property:
        - data (data_model)
        - count (int)
    - supports FastAPI dependencies
    - supports middleware system
    """
    if filter_model is None:
        filter_model = create_model("FilterModel")
    wrapped_dependencies = create_wrapped_fastapi_dependencies(dependencies)
    SelectResponseModel = create_select_response_model(data_model)

    # Create the route with dependencies
    @app.get(
        path,
        response_model=SelectResponseModel,
        dependencies=wrapped_dependencies,
        summary=summary,
        description=description,
    )
    async def get(
        request: Request,
        filters: filter_model = Depends(),  # type: ignore
        limit: int = 100,
        offset: int = 0,
    ):
        """
        This route is automatically generated by dbanu
        """
        # Extract dependency results from request state
        dependency_results = {}
        if request and hasattr(request.state, "dependency_results"):
            dependency_results = request.state.dependency_results
        # Build initial select parameters
        select_args = (
            select_param(filters, limit, offset)
            if select_param is not None
            else [limit, offset]
        )
        # Build initial count parameters
        count_args = count_param(filters) if count_param is not None else []
        # Create initial QueryContext
        initial_context = QueryContext(
            select_query=select_query,
            select_params=select_args,
            count_query=count_query,
            count_params=count_args,
            filters=filters,
            limit=limit,
            offset=offset,
            dependency_results=dependency_results,
        )
        query_processor = _create_query_processor(query_engine, SelectResponseModel)
        handler = create_middleware_chain(middlewares, query_processor)
        return await handler(initial_context)


def _create_query_processor(
    query_engine: SelectEngine, response_model: type[BaseModel]
):
    """Create a query processor for the middleware chain"""

    async def process_query(context: QueryContext):
        select_params = context.select_params or []
        # Check if select method is a coroutine
        select_method = query_engine.select
        if inspect.iscoroutinefunction(select_method):
            data = await select_method(context.select_query, *select_params)
        else:
            data = select_method(context.select_query, *select_params)
        if context.count_query:
            count_params = context.count_params or []
            # Check if select_count method is a coroutine
            select_count_method = query_engine.select_count
            if inspect.iscoroutinefunction(select_count_method):
                total = await select_count_method(context.count_query, *count_params)
            else:
                total = select_count_method(context.count_query, *count_params)
            return response_model(data=data, count=total)
        return response_model(data=data, count=len(data))

    return process_query
